{
    "sourceFile": "backend/middleware/authMiddleware.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1753442195324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753448484933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,73 @@\n const jwt = require(\"jsonwebtoken\");\r\n const User = require(\"../models/models\");\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n-  let token;\r\n-  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n-    try {\r\n-      token = req.headers.authorization.split(\" \")[1];\r\n-      const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n-      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n-      next();\r\n-    } catch (error) {\r\n-      console.error(error);\r\n-      return res.status(401).json({ message: \"Not authorized\" });\r\n+  // Get token from header\r\n+  const authHeader = req.headers.authorization;\r\n+  \r\n+  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\r\n+    return res.status(401).json({\r\n+      success: false,\r\n+      message: \"Authorization token required\",\r\n+      authHelp: \"Format: Bearer <token>\"\r\n+    });\r\n+  }\r\n+\r\n+  const token = authHeader.split(\" \")[1];\r\n+\r\n+  try {\r\n+    // Verify token\r\n+    const decoded = jwt.verify(token, process.env.JWT_SECRET, {\r\n+      algorithms: [\"HS256\"]\r\n+    });\r\n+\r\n+    // Get user from database\r\n+    const user = await User.findById(decoded.id)\r\n+      .select(\"-password -gfgNumber -__v\")\r\n+      .lean();\r\n+\r\n+    if (!user) {\r\n+      return res.status(401).json({\r\n+        success: false,\r\n+        message: \"User not found\",\r\n+        systemAction: \"Token was valid but user doesn't exist\"\r\n+      });\r\n     }\r\n-  } else {\r\n-    return res.status(401).json({ message: \"Not authorized, no token\" });\r\n+\r\n+    // Attach user to request\r\n+    req.user = user;\r\n+    next();\r\n+\r\n+  } catch (error) {\r\n+    console.error(\"Authentication error:\", {\r\n+      error: error.name,\r\n+      message: error.message,\r\n+      timestamp: new Date().toISOString()\r\n+    });\r\n+\r\n+    const response = {\r\n+      success: false,\r\n+      message: \"Not authorized\"\r\n+    };\r\n+\r\n+    if (error.name === \"TokenExpiredError\") {\r\n+      response.message = \"Session expired\";\r\n+      response.suggestion = \"Please log in again\";\r\n+      return res.status(401).json(response);\r\n+    }\r\n+\r\n+    if (error.name === \"JsonWebTokenError\") {\r\n+      response.message = \"Invalid token\";\r\n+      response.suggestion = \"Check your authentication token\";\r\n+      return res.status(401).json(response);\r\n+    }\r\n+\r\n+    return res.status(500).json({\r\n+      success: false,\r\n+      message: \"Authentication failed\",\r\n+      systemSuggestion: \"Please try again later\"\r\n+    });\r\n   }\r\n };\r\n \r\n-module.exports = authMiddleware;\r\n+module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753450163726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,73 +1,30 @@\n const jwt = require(\"jsonwebtoken\");\r\n const User = require(\"../models/models\");\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n-  // Get token from header\r\n-  const authHeader = req.headers.authorization;\r\n+  let token;\r\n   \r\n-  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\r\n-    return res.status(401).json({\r\n-      success: false,\r\n-      message: \"Authorization token required\",\r\n-      authHelp: \"Format: Bearer <token>\"\r\n-    });\r\n-  }\r\n-\r\n-  const token = authHeader.split(\" \")[1];\r\n-\r\n-  try {\r\n-    // Verify token\r\n-    const decoded = jwt.verify(token, process.env.JWT_SECRET, {\r\n-      algorithms: [\"HS256\"]\r\n-    });\r\n-\r\n-    // Get user from database\r\n-    const user = await User.findById(decoded.id)\r\n-      .select(\"-password -gfgNumber -__v\")\r\n-      .lean();\r\n-\r\n-    if (!user) {\r\n-      return res.status(401).json({\r\n-        success: false,\r\n-        message: \"User not found\",\r\n-        systemAction: \"Token was valid but user doesn't exist\"\r\n-      });\r\n+  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n+    try {\r\n+      // Get token from header\r\n+      token = req.headers.authorization.split(\" \")[1];\r\n+      \r\n+      // Verify token\r\n+      const decoded = jwt.verify(token, process.env.JWT_SECRET || \"your_jwt_secret\");\r\n+      \r\n+      // Get user from token\r\n+      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n+      \r\n+      next();\r\n+    } catch (error) {\r\n+      console.error(error);\r\n+      res.status(401).json({ message: \"Not authorized\" });\r\n     }\r\n-\r\n-    // Attach user to request\r\n-    req.user = user;\r\n-    next();\r\n-\r\n-  } catch (error) {\r\n-    console.error(\"Authentication error:\", {\r\n-      error: error.name,\r\n-      message: error.message,\r\n-      timestamp: new Date().toISOString()\r\n-    });\r\n-\r\n-    const response = {\r\n-      success: false,\r\n-      message: \"Not authorized\"\r\n-    };\r\n-\r\n-    if (error.name === \"TokenExpiredError\") {\r\n-      response.message = \"Session expired\";\r\n-      response.suggestion = \"Please log in again\";\r\n-      return res.status(401).json(response);\r\n-    }\r\n-\r\n-    if (error.name === \"JsonWebTokenError\") {\r\n-      response.message = \"Invalid token\";\r\n-      response.suggestion = \"Check your authentication token\";\r\n-      return res.status(401).json(response);\r\n-    }\r\n-\r\n-    return res.status(500).json({\r\n-      success: false,\r\n-      message: \"Authentication failed\",\r\n-      systemSuggestion: \"Please try again later\"\r\n-    });\r\n   }\r\n+  \r\n+  if (!token) {\r\n+    res.status(401).json({ message: \"Not authorized, no token\" });\r\n+  }\r\n };\r\n \r\n module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753453270734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,30 +1,73 @@\n const jwt = require(\"jsonwebtoken\");\r\n const User = require(\"../models/models\");\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n-  let token;\r\n+  // Get token from header\r\n+  const authHeader = req.headers.authorization;\r\n   \r\n-  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n-    try {\r\n-      // Get token from header\r\n-      token = req.headers.authorization.split(\" \")[1];\r\n-      \r\n-      // Verify token\r\n-      const decoded = jwt.verify(token, process.env.JWT_SECRET || \"your_jwt_secret\");\r\n-      \r\n-      // Get user from token\r\n-      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n-      \r\n-      next();\r\n-    } catch (error) {\r\n-      console.error(error);\r\n-      res.status(401).json({ message: \"Not authorized\" });\r\n+  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\r\n+    return res.status(401).json({\r\n+      success: false,\r\n+      message: \"Authorization token required\",\r\n+      authHelp: \"Format: Bearer <token>\"\r\n+    });\r\n+  }\r\n+\r\n+  const token = authHeader.split(\" \")[1];\r\n+\r\n+  try {\r\n+    // Verify token\r\n+    const decoded = jwt.verify(token, process.env.JWT_SECRET, {\r\n+      algorithms: [\"HS256\"]\r\n+    });\r\n+\r\n+    // Get user from database\r\n+    const user = await User.findById(decoded.id)\r\n+      .select(\"-password -gfgNumber -__v\")\r\n+      .lean();\r\n+\r\n+    if (!user) {\r\n+      return res.status(401).json({\r\n+        success: false,\r\n+        message: \"User not found\",\r\n+        systemAction: \"Token was valid but user doesn't exist\"\r\n+      });\r\n     }\r\n+\r\n+    // Attach user to request\r\n+    req.user = user;\r\n+    next();\r\n+\r\n+  } catch (error) {\r\n+    console.error(\"Authentication error:\", {\r\n+      error: error.name,\r\n+      message: error.message,\r\n+      timestamp: new Date().toISOString()\r\n+    });\r\n+\r\n+    const response = {\r\n+      success: false,\r\n+      message: \"Not authorized\"\r\n+    };\r\n+\r\n+    if (error.name === \"TokenExpiredError\") {\r\n+      response.message = \"Session expired\";\r\n+      response.suggestion = \"Please log in again\";\r\n+      return res.status(401).json(response);\r\n+    }\r\n+\r\n+    if (error.name === \"JsonWebTokenError\") {\r\n+      response.message = \"Invalid token\";\r\n+      response.suggestion = \"Check your authentication token\";\r\n+      return res.status(401).json(response);\r\n+    }\r\n+\r\n+    return res.status(500).json({\r\n+      success: false,\r\n+      message: \"Authentication failed\",\r\n+      systemSuggestion: \"Please try again later\"\r\n+    });\r\n   }\r\n-  \r\n-  if (!token) {\r\n-    res.status(401).json({ message: \"Not authorized, no token\" });\r\n-  }\r\n };\r\n \r\n module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753453531645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,73 +1,124 @@\n-const jwt = require(\"jsonwebtoken\");\r\n-const User = require(\"../models/models\");\r\n+const mongoose = require(\"mongoose\");\r\n+const bcrypt = require(\"bcryptjs\");\r\n \r\n-const authMiddleware = async (req, res, next) => {\r\n-  // Get token from header\r\n-  const authHeader = req.headers.authorization;\r\n-  \r\n-  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\r\n-    return res.status(401).json({\r\n-      success: false,\r\n-      message: \"Authorization token required\",\r\n-      authHelp: \"Format: Bearer <token>\"\r\n-    });\r\n-  }\r\n+// 📄 Subschema for 528-specific document verification\r\n+const documentSchema = new mongoose.Schema(\r\n+  {\r\n+    politicalDeclaration: { type: String },\r\n+    witnessTestimonies: [{ type: String }],\r\n+    idDocument: {\r\n+      type: String,\r\n+      enum: [\"DriverLicense\", \"Passport\", \"NationalID\"],\r\n+    },\r\n+    idDocumentFile: { type: String },\r\n+    photoWithWhiteBg: { type: String },\r\n+    redThumbprint: { type: String },\r\n+    utilityBill: { type: String },\r\n+    isValid: { type: Boolean, default: false },\r\n+  },\r\n+  { _id: false }\r\n+);\r\n \r\n-  const token = authHeader.split(\" \")[1];\r\n+// 👤 Main user schema\r\n+const userSchema = new mongoose.Schema(\r\n+  {\r\n+    fullNames: {\r\n+      type: String,\r\n+      required: [true, \"Full names are required\"],\r\n+      trim: true,\r\n+    },\r\n+    familyName: {\r\n+      type: String,\r\n+      required: [true, \"Family name is required\"],\r\n+      trim: true,\r\n+    },\r\n+    email: {\r\n+      type: String,\r\n+      required: [true, \"Email is required\"],\r\n+      unique: true,\r\n+      lowercase: true,\r\n+      trim: true,\r\n+    },\r\n+    password: {\r\n+      type: String,\r\n+      required: [true, \"Password is required\"],\r\n+      minlength: 6,\r\n+    },\r\n+    gfgNumber: {\r\n+      type: String,\r\n+      required: [true, \"GFG number is required\"],\r\n+    },\r\n+    documentLabel: {\r\n+      type: String,\r\n+      enum: [\"528\", \"928\", \"Praecipe\"],\r\n+      required: [true, \"Document label is required\"],\r\n+    },\r\n+    documentRequirements: {\r\n+      type: documentSchema,\r\n+      required: function () {\r\n+        return this.documentLabel === \"528\";\r\n\\ No newline at end of file\n+      },\r\n+    },\r\n+  },\r\n+  { timestamps: true }\r\n+);\r\n \r\n+// 🔒 Hash password and GFG number before saving\r\n+userSchema.pre(\"save\", async function (next) {\r\n   try {\r\n-    // Verify token\r\n-    const decoded = jwt.verify(token, process.env.JWT_SECRET, {\r\n-      algorithms: [\"HS256\"]\r\n-    });\r\n+    if (this.isModified(\"password\")) {\r\n+      const salt = await bcrypt.genSalt(10);\r\n+      this.password = await bcrypt.hash(this.password, salt);\r\n+    }\r\n \r\n-    // Get user from database\r\n-    const user = await User.findById(decoded.id)\r\n-      .select(\"-password -gfgNumber -__v\")\r\n-      .lean();\r\n-\r\n-    if (!user) {\r\n-      return res.status(401).json({\r\n-        success: false,\r\n-        message: \"User not found\",\r\n-        systemAction: \"Token was valid but user doesn't exist\"\r\n-      });\r\n+    if (this.isModified(\"gfgNumber\")) {\r\n+      const salt = await bcrypt.genSalt(10);\r\n+      this.gfgNumber = await bcrypt.hash(this.gfgNumber, salt);\r\n     }\r\n \r\n-    // Attach user to request\r\n-    req.user = user;\r\n     next();\r\n+  } catch (err) {\r\n+    next(err);\r\n+  }\r\n+});\r\n \r\n-  } catch (error) {\r\n-    console.error(\"Authentication error:\", {\r\n-      error: error.name,\r\n-      message: error.message,\r\n-      timestamp: new Date().toISOString()\r\n-    });\r\n+// 🧠 Instance methods\r\n+userSchema.methods.comparePassword = async function (candidatePassword) {\r\n+  return bcrypt.compare(candidatePassword, this.password);\r\n+};\r\n \r\n-    const response = {\r\n-      success: false,\r\n-      message: \"Not authorized\"\r\n-    };\r\n+userSchema.methods.compareGfgNumber = async function (candidateGfgNumber) {\r\n+  return bcrypt.compare(candidateGfgNumber, this.gfgNumber);\r\n+};\r\n \r\n-    if (error.name === \"TokenExpiredError\") {\r\n-      response.message = \"Session expired\";\r\n-      response.suggestion = \"Please log in again\";\r\n-      return res.status(401).json(response);\r\n-    }\r\n+module.exports = mongoose.model(\"User\", userSchema);\r\n+ this is my authMiddleware.js const jwt = require(\"jsonwebtoken\");\r\n+const User = require(\"../models/models\");\r\n \r\n-    if (error.name === \"JsonWebTokenError\") {\r\n-      response.message = \"Invalid token\";\r\n-      response.suggestion = \"Check your authentication token\";\r\n-      return res.status(401).json(response);\r\n+const authMiddleware = async (req, res, next) => {\r\n+  let token;\r\n+  \r\n+  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n+    try {\r\n+      // Get token from header\r\n+      token = req.headers.authorization.split(\" \")[1];\r\n+      \r\n+      // Verify token\r\n+      const decoded = jwt.verify(token, process.env.JWT_SECRET || \"your_jwt_secret\");\r\n+      \r\n+      // Get user from token\r\n+      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n+      \r\n+      next();\r\n+    } catch (error) {\r\n+      console.error(error);\r\n+      res.status(401).json({ message: \"Not authorized\" });\r\n     }\r\n-\r\n-    return res.status(500).json({\r\n-      success: false,\r\n-      message: \"Authentication failed\",\r\n-      systemSuggestion: \"Please try again later\"\r\n-    });\r\n   }\r\n+  \r\n+  if (!token) {\r\n+    res.status(401).json({ message: \"Not authorized, no token\" });\r\n+  }\r\n };\r\n \r\n-module.exports = authMiddleware;\n+module.exports = authMiddleware; \n\\ No newline at end of file\n"
                },
                {
                    "date": 1753453587216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,124 @@\n+const mongoose = require(\"mongoose\");\r\n+const bcrypt = require(\"bcryptjs\");\r\n+\r\n+// 📄 Subschema for 528-specific document verification\r\n+const documentSchema = new mongoose.Schema(\r\n+  {\r\n+    politicalDeclaration: { type: String },\r\n+    witnessTestimonies: [{ type: String }],\r\n+    idDocument: {\r\n+      type: String,\r\n+      enum: [\"DriverLicense\", \"Passport\", \"NationalID\"],\r\n+    },\r\n+    idDocumentFile: { type: String },\r\n+    photoWithWhiteBg: { type: String },\r\n+    redThumbprint: { type: String },\r\n+    utilityBill: { type: String },\r\n+    isValid: { type: Boolean, default: false },\r\n+  },\r\n+  { _id: false }\r\n+);\r\n+\r\n+// 👤 Main user schema\r\n+const userSchema = new mongoose.Schema(\r\n+  {\r\n+    fullNames: {\r\n+      type: String,\r\n+      required: [true, \"Full names are required\"],\r\n+      trim: true,\r\n+    },\r\n+    familyName: {\r\n+      type: String,\r\n+      required: [true, \"Family name is required\"],\r\n+      trim: true,\r\n+    },\r\n+    email: {\r\n+      type: String,\r\n+      required: [true, \"Email is required\"],\r\n+      unique: true,\r\n+      lowercase: true,\r\n+      trim: true,\r\n+    },\r\n+    password: {\r\n+      type: String,\r\n+      required: [true, \"Password is required\"],\r\n+      minlength: 6,\r\n+    },\r\n+    gfgNumber: {\r\n+      type: String,\r\n+      required: [true, \"GFG number is required\"],\r\n+    },\r\n+    documentLabel: {\r\n+      type: String,\r\n+      enum: [\"528\", \"928\", \"Praecipe\"],\r\n+      required: [true, \"Document label is required\"],\r\n+    },\r\n+    documentRequirements: {\r\n+      type: documentSchema,\r\n+      required: function () {\r\n+        return this.documentLabel === \"528\";\r\n+      },\r\n+    },\r\n+  },\r\n+  { timestamps: true }\r\n+);\r\n+\r\n+// 🔒 Hash password and GFG number before saving\r\n+userSchema.pre(\"save\", async function (next) {\r\n+  try {\r\n+    if (this.isModified(\"password\")) {\r\n+      const salt = await bcrypt.genSalt(10);\r\n+      this.password = await bcrypt.hash(this.password, salt);\r\n+    }\r\n+\r\n+    if (this.isModified(\"gfgNumber\")) {\r\n+      const salt = await bcrypt.genSalt(10);\r\n+      this.gfgNumber = await bcrypt.hash(this.gfgNumber, salt);\r\n+    }\r\n+\r\n+    next();\r\n+  } catch (err) {\r\n+    next(err);\r\n+  }\r\n+});\r\n+\r\n+// 🧠 Instance methods\r\n+userSchema.methods.comparePassword = async function (candidatePassword) {\r\n+  return bcrypt.compare(candidatePassword, this.password);\r\n+};\r\n+\r\n+userSchema.methods.compareGfgNumber = async function (candidateGfgNumber) {\r\n+  return bcrypt.compare(candidateGfgNumber, this.gfgNumber);\r\n+};\r\n+\r\n+module.exports = mongoose.model(\"User\", userSchema);\r\n+ const jwt = require(\"jsonwebtoken\");\r\n+const User = require(\"../models/models\");\r\n+\r\n+const authMiddleware = async (req, res, next) => {\r\n+  let token;\r\n+  \r\n+  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n+    try {\r\n+      // Get token from header\r\n+      token = req.headers.authorization.split(\" \")[1];\r\n+      \r\n+      // Verify token\r\n+      const decoded = jwt.verify(token, process.env.JWT_SECRET || \"your_jwt_secret\");\r\n+      \r\n+      // Get user from token\r\n+      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n+      \r\n+      next();\r\n+    } catch (error) {\r\n+      console.error(error);\r\n+      res.status(401).json({ message: \"Not authorized\" });\r\n+    }\r\n+  }\r\n+  \r\n+  if (!token) {\r\n+    res.status(401).json({ message: \"Not authorized, no token\" });\r\n+  }\r\n+};\r\n+\r\n+module.exports = authMiddleware; \n\\ No newline at end of file\n"
                },
                {
                    "date": 1753453978868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,99 +1,5 @@\n-const mongoose = require(\"mongoose\");\r\n-const bcrypt = require(\"bcryptjs\");\r\n-\r\n-// 📄 Subschema for 528-specific document verification\r\n-const documentSchema = new mongoose.Schema(\r\n-  {\r\n-    politicalDeclaration: { type: String },\r\n-    witnessTestimonies: [{ type: String }],\r\n-    idDocument: {\r\n-      type: String,\r\n-      enum: [\"DriverLicense\", \"Passport\", \"NationalID\"],\r\n-    },\r\n-    idDocumentFile: { type: String },\r\n-    photoWithWhiteBg: { type: String },\r\n-    redThumbprint: { type: String },\r\n-    utilityBill: { type: String },\r\n-    isValid: { type: Boolean, default: false },\r\n-  },\r\n-  { _id: false }\r\n-);\r\n-\r\n-// 👤 Main user schema\r\n-const userSchema = new mongoose.Schema(\r\n-  {\r\n-    fullNames: {\r\n-      type: String,\r\n-      required: [true, \"Full names are required\"],\r\n-      trim: true,\r\n-    },\r\n-    familyName: {\r\n-      type: String,\r\n-      required: [true, \"Family name is required\"],\r\n-      trim: true,\r\n-    },\r\n-    email: {\r\n-      type: String,\r\n-      required: [true, \"Email is required\"],\r\n-      unique: true,\r\n-      lowercase: true,\r\n-      trim: true,\r\n-    },\r\n-    password: {\r\n-      type: String,\r\n-      required: [true, \"Password is required\"],\r\n-      minlength: 6,\r\n-    },\r\n-    gfgNumber: {\r\n-      type: String,\r\n-      required: [true, \"GFG number is required\"],\r\n-    },\r\n-    documentLabel: {\r\n-      type: String,\r\n-      enum: [\"528\", \"928\", \"Praecipe\"],\r\n-      required: [true, \"Document label is required\"],\r\n-    },\r\n-    documentRequirements: {\r\n-      type: documentSchema,\r\n-      required: function () {\r\n-        return this.documentLabel === \"528\";\r\n-      },\r\n-    },\r\n-  },\r\n-  { timestamps: true }\r\n-);\r\n-\r\n-// 🔒 Hash password and GFG number before saving\r\n-userSchema.pre(\"save\", async function (next) {\r\n-  try {\r\n-    if (this.isModified(\"password\")) {\r\n-      const salt = await bcrypt.genSalt(10);\r\n-      this.password = await bcrypt.hash(this.password, salt);\r\n-    }\r\n-\r\n-    if (this.isModified(\"gfgNumber\")) {\r\n-      const salt = await bcrypt.genSalt(10);\r\n-      this.gfgNumber = await bcrypt.hash(this.gfgNumber, salt);\r\n-    }\r\n-\r\n-    next();\r\n-  } catch (err) {\r\n-    next(err);\r\n-  }\r\n-});\r\n-\r\n-// 🧠 Instance methods\r\n-userSchema.methods.comparePassword = async function (candidatePassword) {\r\n-  return bcrypt.compare(candidatePassword, this.password);\r\n-};\r\n-\r\n-userSchema.methods.compareGfgNumber = async function (candidateGfgNumber) {\r\n-  return bcrypt.compare(candidateGfgNumber, this.gfgNumber);\r\n-};\r\n-\r\n-module.exports = mongoose.model(\"User\", userSchema);\r\n- const jwt = require(\"jsonwebtoken\");\r\n+const jwt = require(\"jsonwebtoken\");\r\n const User = require(\"../models/models\");\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n   let token;\r\n@@ -120,129 +26,5 @@\n     res.status(401).json({ message: \"Not authorized, no token\" });\r\n   }\r\n };\r\n \r\n-module.exports = authMiddleware; \n-const mongoose = require(\"mongoose\");\r\n-const bcrypt = require(\"bcryptjs\");\r\n-\r\n-// 📄 Subschema for 528-specific document verification\r\n-const documentSchema = new mongoose.Schema(\r\n-  {\r\n-    politicalDeclaration: { type: String },\r\n-    witnessTestimonies: [{ type: String }],\r\n-    idDocument: {\r\n-      type: String,\r\n-      enum: [\"DriverLicense\", \"Passport\", \"NationalID\"],\r\n-    },\r\n-    idDocumentFile: { type: String },\r\n-    photoWithWhiteBg: { type: String },\r\n-    redThumbprint: { type: String },\r\n-    utilityBill: { type: String },\r\n-    isValid: { type: Boolean, default: false },\r\n-  },\r\n-  { _id: false }\r\n-);\r\n-\r\n-// 👤 Main user schema\r\n-const userSchema = new mongoose.Schema(\r\n-  {\r\n-    fullNames: {\r\n-      type: String,\r\n-      required: [true, \"Full names are required\"],\r\n-      trim: true,\r\n-    },\r\n-    familyName: {\r\n-      type: String,\r\n-      required: [true, \"Family name is required\"],\r\n-      trim: true,\r\n-    },\r\n-    email: {\r\n-      type: String,\r\n-      required: [true, \"Email is required\"],\r\n-      unique: true,\r\n-      lowercase: true,\r\n-      trim: true,\r\n-    },\r\n-    password: {\r\n-      type: String,\r\n-      required: [true, \"Password is required\"],\r\n-      minlength: 6,\r\n-    },\r\n-    gfgNumber: {\r\n-      type: String,\r\n-      required: [true, \"GFG number is required\"],\r\n-    },\r\n-    documentLabel: {\r\n-      type: String,\r\n-      enum: [\"528\", \"928\", \"Praecipe\"],\r\n-      required: [true, \"Document label is required\"],\r\n-    },\r\n-    documentRequirements: {\r\n-      type: documentSchema,\r\n-      required: function () {\r\n-        return this.documentLabel === \"528\";\r\n-      },\r\n-    },\r\n-  },\r\n-  { timestamps: true }\r\n-);\r\n-\r\n-// 🔒 Hash password and GFG number before saving\r\n-userSchema.pre(\"save\", async function (next) {\r\n-  try {\r\n-    if (this.isModified(\"password\")) {\r\n-      const salt = await bcrypt.genSalt(10);\r\n-      this.password = await bcrypt.hash(this.password, salt);\r\n-    }\r\n-\r\n-    if (this.isModified(\"gfgNumber\")) {\r\n-      const salt = await bcrypt.genSalt(10);\r\n-      this.gfgNumber = await bcrypt.hash(this.gfgNumber, salt);\r\n-    }\r\n-\r\n-    next();\r\n-  } catch (err) {\r\n-    next(err);\r\n-  }\r\n-});\r\n-\r\n-// 🧠 Instance methods\r\n-userSchema.methods.comparePassword = async function (candidatePassword) {\r\n-  return bcrypt.compare(candidatePassword, this.password);\r\n-};\r\n-\r\n-userSchema.methods.compareGfgNumber = async function (candidateGfgNumber) {\r\n-  return bcrypt.compare(candidateGfgNumber, this.gfgNumber);\r\n-};\r\n-\r\n-module.exports = mongoose.model(\"User\", userSchema);\r\n- this is my authMiddleware.js const jwt = require(\"jsonwebtoken\");\r\n-const User = require(\"../models/models\");\r\n-\r\n-const authMiddleware = async (req, res, next) => {\r\n-  let token;\r\n-  \r\n-  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n-    try {\r\n-      // Get token from header\r\n-      token = req.headers.authorization.split(\" \")[1];\r\n-      \r\n-      // Verify token\r\n-      const decoded = jwt.verify(token, process.env.JWT_SECRET || \"your_jwt_secret\");\r\n-      \r\n-      // Get user from token\r\n-      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n-      \r\n-      next();\r\n-    } catch (error) {\r\n-      console.error(error);\r\n-      res.status(401).json({ message: \"Not authorized\" });\r\n-    }\r\n-  }\r\n-  \r\n-  if (!token) {\r\n-    res.status(401).json({ message: \"Not authorized, no token\" });\r\n-  }\r\n-};\r\n-\r\n-module.exports = authMiddleware; \n\\ No newline at end of file\n+module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753472640099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,30 +1,80 @@\n const jwt = require(\"jsonwebtoken\");\r\n-const User = require(\"../models/models\");\r\n+const User = require(\"../models/User\"); // Make sure this path is correct\r\n+const config = require(\"../config/db\"); // Assuming you have a config file\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n   let token;\r\n   \r\n-  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n-    try {\r\n-      // Get token from header\r\n-      token = req.headers.authorization.split(\" \")[1];\r\n-      \r\n-      // Verify token\r\n-      const decoded = jwt.verify(token, process.env.JWT_SECRET || \"your_jwt_secret\");\r\n-      \r\n-      // Get user from token\r\n-      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n-      \r\n-      next();\r\n-    } catch (error) {\r\n-      console.error(error);\r\n-      res.status(401).json({ message: \"Not authorized\" });\r\n-    }\r\n+  // Check for token in multiple locations\r\n+  if (\r\n+    req.headers.authorization && \r\n+    req.headers.authorization.startsWith(\"Bearer\")\r\n+  ) {\r\n+    token = req.headers.authorization.split(\" \")[1];\r\n+  } \r\n+  else if (req.cookies?.token) {\r\n+    token = req.cookies.token;\r\n   }\r\n-  \r\n+  else if (req.headers['x-auth-token']) {\r\n+    token = req.headers['x-auth-token'];\r\n+  }\r\n+\r\n   if (!token) {\r\n-    res.status(401).json({ message: \"Not authorized, no token\" });\r\n+    return res.status(401).json({ \r\n+      success: false,\r\n+      message: \"Not authorized, no token provided\" \r\n+    });\r\n   }\r\n+\r\n+  try {\r\n+    // Verify token\r\n+    const decoded = jwt.verify(token, config.JWT_SECRET || process.env.JWT_SECRET);\r\n+    \r\n+    // Get user from token\r\n+    const user = await User.findById(decoded.id).select(\"-password\");\r\n+    \r\n+    if (!user) {\r\n+      return res.status(401).json({ \r\n+        success: false,\r\n+        message: \"User not found\" \r\n+      });\r\n+    }\r\n+\r\n+    // Check if user changed password after token was issued\r\n+    if (user.passwordChangedAfter(decoded.iat)) {\r\n+      return res.status(401).json({ \r\n+        success: false,\r\n+        message: \"Password was changed recently. Please log in again.\" \r\n+      });\r\n+    }\r\n+\r\n+    // Attach user to request object\r\n+    req.user = user;\r\n+    next();\r\n+  } catch (error) {\r\n+    console.error(\"Authentication error:\", error.message);\r\n+    \r\n+    let message = \"Not authorized\";\r\n+    if (error.name === \"TokenExpiredError\") {\r\n+      message = \"Session expired. Please log in again.\";\r\n+    } else if (error.name === \"JsonWebTokenError\") {\r\n+      message = \"Invalid token\";\r\n+    }\r\n+\r\n+    res.status(401).json({ \r\n+      success: false,\r\n+      message \r\n+    });\r\n+  }\r\n };\r\n \r\n+// Add this to your User model for password change checking\r\n+User.methods.passwordChangedAfter = function(JWTTimestamp) {\r\n+  if (this.passwordChangedAt) {\r\n+    const changedTimestamp = parseInt(this.passwordChangedAt.getTime() / 1000, 10);\r\n+    return JWTTimestamp < changedTimestamp;\r\n+  }\r\n+  return false;\r\n+};\r\n+\r\n module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753472926797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n const jwt = require(\"jsonwebtoken\");\r\n-const User = require(\"../models/User\"); // Make sure this path is correct\r\n+const User = require(\"../models/models\")\r\n const config = require(\"../config/db\"); // Assuming you have a config file\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n   let token;\r\n"
                },
                {
                    "date": 1753473227941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,16 +1,13 @@\n const jwt = require(\"jsonwebtoken\");\r\n-const User = require(\"../models/models\")\r\n-const config = require(\"../config/db\"); // Assuming you have a config file\r\n+const User = require(\"../models/models\"); // Make sure this path is correct\r\n+const config = require(\"../config/db\");\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n   let token;\r\n   \r\n   // Check for token in multiple locations\r\n-  if (\r\n-    req.headers.authorization && \r\n-    req.headers.authorization.startsWith(\"Bearer\")\r\n-  ) {\r\n+  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n     token = req.headers.authorization.split(\" \")[1];\r\n   } \r\n   else if (req.cookies?.token) {\r\n     token = req.cookies.token;\r\n@@ -67,14 +64,5 @@\n     });\r\n   }\r\n };\r\n \r\n-// Add this to your User model for password change checking\r\n-User.methods.passwordChangedAfter = function(JWTTimestamp) {\r\n-  if (this.passwordChangedAt) {\r\n-    const changedTimestamp = parseInt(this.passwordChangedAt.getTime() / 1000, 10);\r\n-    return JWTTimestamp < changedTimestamp;\r\n-  }\r\n-  return false;\r\n-};\r\n-\r\n module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753473673566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,16 @@\n const jwt = require(\"jsonwebtoken\");\r\n-const User = require(\"../models/models\"); // Make sure this path is correct\r\n-const config = require(\"../config/db\");\r\n+const User = require(\"../models/User\"); // Make sure this path is correct\r\n+const config = require(\"../config/db\"); // Assuming you have a config file\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n   let token;\r\n   \r\n   // Check for token in multiple locations\r\n-  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n+  if (\r\n+    req.headers.authorization && \r\n+    req.headers.authorization.startsWith(\"Bearer\")\r\n+  ) {\r\n     token = req.headers.authorization.split(\" \")[1];\r\n   } \r\n   else if (req.cookies?.token) {\r\n     token = req.cookies.token;\r\n@@ -64,5 +67,14 @@\n     });\r\n   }\r\n };\r\n \r\n+// Add this to your User model for password change checking\r\n+User.methods.passwordChangedAfter = function(JWTTimestamp) {\r\n+  if (this.passwordChangedAt) {\r\n+    const changedTimestamp = parseInt(this.passwordChangedAt.getTime() / 1000, 10);\r\n+    return JWTTimestamp < changedTimestamp;\r\n+  }\r\n+  return false;\r\n+};\r\n+\r\n module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753473700548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,80 +1,30 @@\n const jwt = require(\"jsonwebtoken\");\r\n-const User = require(\"../models/User\"); // Make sure this path is correct\r\n-const config = require(\"../config/db\"); // Assuming you have a config file\r\n+const User = require(\"../models/models\");\r\n \r\n const authMiddleware = async (req, res, next) => {\r\n   let token;\r\n   \r\n-  // Check for token in multiple locations\r\n-  if (\r\n-    req.headers.authorization && \r\n-    req.headers.authorization.startsWith(\"Bearer\")\r\n-  ) {\r\n-    token = req.headers.authorization.split(\" \")[1];\r\n-  } \r\n-  else if (req.cookies?.token) {\r\n-    token = req.cookies.token;\r\n+  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n+    try {\r\n+      // Get token from header\r\n+      token = req.headers.authorization.split(\" \")[1];\r\n+      \r\n+      // Verify token\r\n+      const decoded = jwt.verify(token, process.env.JWT_SECRET || \"your_jwt_secret\");\r\n+      \r\n+      // Get user from token\r\n+      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n+      \r\n+      next();\r\n+    } catch (error) {\r\n+      console.error(error);\r\n+      res.status(401).json({ message: \"Not authorized\" });\r\n+    }\r\n   }\r\n-  else if (req.headers['x-auth-token']) {\r\n-    token = req.headers['x-auth-token'];\r\n-  }\r\n-\r\n+  \r\n   if (!token) {\r\n-    return res.status(401).json({ \r\n-      success: false,\r\n-      message: \"Not authorized, no token provided\" \r\n-    });\r\n+    res.status(401).json({ message: \"Not authorized, no token\" });\r\n   }\r\n-\r\n-  try {\r\n-    // Verify token\r\n-    const decoded = jwt.verify(token, config.JWT_SECRET || process.env.JWT_SECRET);\r\n-    \r\n-    // Get user from token\r\n-    const user = await User.findById(decoded.id).select(\"-password\");\r\n-    \r\n-    if (!user) {\r\n-      return res.status(401).json({ \r\n-        success: false,\r\n-        message: \"User not found\" \r\n-      });\r\n-    }\r\n-\r\n-    // Check if user changed password after token was issued\r\n-    if (user.passwordChangedAfter(decoded.iat)) {\r\n-      return res.status(401).json({ \r\n-        success: false,\r\n-        message: \"Password was changed recently. Please log in again.\" \r\n-      });\r\n-    }\r\n-\r\n-    // Attach user to request object\r\n-    req.user = user;\r\n-    next();\r\n-  } catch (error) {\r\n-    console.error(\"Authentication error:\", error.message);\r\n-    \r\n-    let message = \"Not authorized\";\r\n-    if (error.name === \"TokenExpiredError\") {\r\n-      message = \"Session expired. Please log in again.\";\r\n-    } else if (error.name === \"JsonWebTokenError\") {\r\n-      message = \"Invalid token\";\r\n-    }\r\n-\r\n-    res.status(401).json({ \r\n-      success: false,\r\n-      message \r\n-    });\r\n-  }\r\n };\r\n \r\n-// Add this to your User model for password change checking\r\n-User.methods.passwordChangedAfter = function(JWTTimestamp) {\r\n-  if (this.passwordChangedAt) {\r\n-    const changedTimestamp = parseInt(this.passwordChangedAt.getTime() / 1000, 10);\r\n-    return JWTTimestamp < changedTimestamp;\r\n-  }\r\n-  return false;\r\n-};\r\n-\r\n module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753692821497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n       // Get token from header\r\n       token = req.headers.authorization.split(\" \")[1];\r\n       \r\n       // Verify token\r\n-      const decoded = jwt.verify(token, process.env.JWT_SECRET || \"your_jwt_secret\");\r\n+     const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n       \r\n       // Get user from token\r\n       req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n       \r\n"
                },
                {
                    "date": 1753698926909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,28 +3,46 @@\n \r\n const authMiddleware = async (req, res, next) => {\r\n   let token;\r\n   \r\n-  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n-    try {\r\n-      // Get token from header\r\n-      token = req.headers.authorization.split(\" \")[1];\r\n-      \r\n-      // Verify token\r\n-     const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n-      \r\n-      // Get user from token\r\n-      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n-      \r\n-      next();\r\n-    } catch (error) {\r\n-      console.error(error);\r\n-      res.status(401).json({ message: \"Not authorized\" });\r\n+  // Check for token\r\n+  if (!req.headers.authorization || !req.headers.authorization.startsWith(\"Bearer\")) {\r\n+    return res.status(401).json({ message: \"Not authorized, no token\" });\r\n+  }\r\n+\r\n+  try {\r\n+    // Get token from header\r\n+    token = req.headers.authorization.split(\" \")[1];\r\n+    \r\n+    // Verify token\r\n+    const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n+    \r\n+    // Get user from token\r\n+    req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n+    \r\n+    if (!req.user) {\r\n+      return res.status(401).json({ message: \"User not found\" });\r\n     }\r\n+    \r\n+    next();\r\n+  } catch (error) {\r\n+    console.error(\"JWT Error:\", error.message);\r\n+    \r\n+    // More specific error messages\r\n+    if (error.name === \"JsonWebTokenError\") {\r\n+      return res.status(401).json({ \r\n+        message: \"Invalid token\",\r\n+        details: error.message \r\n+      });\r\n+    }\r\n+    if (error.name === \"TokenExpiredError\") {\r\n+      return res.status(401).json({ message: \"Token expired\" });\r\n+    }\r\n+    \r\n+    return res.status(401).json({ \r\n+      message: \"Not authorized\",\r\n+      error: error.message \r\n+    });\r\n   }\r\n-  \r\n-  if (!token) {\r\n-    res.status(401).json({ message: \"Not authorized, no token\" });\r\n-  }\r\n };\r\n \r\n module.exports = authMiddleware;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753700843739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,46 +3,28 @@\n \r\n const authMiddleware = async (req, res, next) => {\r\n   let token;\r\n   \r\n-  // Check for token\r\n-  if (!req.headers.authorization || !req.headers.authorization.startsWith(\"Bearer\")) {\r\n-    return res.status(401).json({ message: \"Not authorized, no token\" });\r\n-  }\r\n-\r\n-  try {\r\n-    // Get token from header\r\n-    token = req.headers.authorization.split(\" \")[1];\r\n-    \r\n-    // Verify token\r\n-    const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n-    \r\n-    // Get user from token\r\n-    req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n-    \r\n-    if (!req.user) {\r\n-      return res.status(401).json({ message: \"User not found\" });\r\n+  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n+    try {\r\n+      // Get token from header\r\n+      token = req.headers.authorization.split(\" \")[1];\r\n+      \r\n+      // Verify token\r\n+     const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n+      \r\n+      // Get user from token\r\n+      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n+      \r\n+      next();\r\n+    } catch (error) {\r\n+      console.error(error);\r\n+      res.status(401).json({ message: \"Not authorized\" });\r\n     }\r\n-    \r\n-    next();\r\n-  } catch (error) {\r\n-    console.error(\"JWT Error:\", error.message);\r\n-    \r\n-    // More specific error messages\r\n-    if (error.name === \"JsonWebTokenError\") {\r\n-      return res.status(401).json({ \r\n-        message: \"Invalid token\",\r\n-        details: error.message \r\n-      });\r\n-    }\r\n-    if (error.name === \"TokenExpiredError\") {\r\n-      return res.status(401).json({ message: \"Token expired\" });\r\n-    }\r\n-    \r\n-    return res.status(401).json({ \r\n-      message: \"Not authorized\",\r\n-      error: error.message \r\n-    });\r\n   }\r\n+  \r\n+  if (!token) {\r\n+    res.status(401).json({ message: \"Not authorized, no token\" });\r\n+  }\r\n };\r\n \r\n module.exports = authMiddleware;\n\\ No newline at end of file\n"
                }
            ],
            "date": 1753442195324,
            "name": "Commit-0",
            "content": "const jwt = require(\"jsonwebtoken\");\r\nconst User = require(\"../models/models\");\r\n\r\nconst authMiddleware = async (req, res, next) => {\r\n  let token;\r\n  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer\")) {\r\n    try {\r\n      token = req.headers.authorization.split(\" \")[1];\r\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n      req.user = await User.findById(decoded.id).select(\"-password -gfgNumber\");\r\n      next();\r\n    } catch (error) {\r\n      console.error(error);\r\n      return res.status(401).json({ message: \"Not authorized\" });\r\n    }\r\n  } else {\r\n    return res.status(401).json({ message: \"Not authorized, no token\" });\r\n  }\r\n};\r\n\r\nmodule.exports = authMiddleware;\r\n"
        }
    ]
}